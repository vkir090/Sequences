<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <title>Sequences – Quant Prep (Solo)</title>
  <style>
    :root{--bg:#0f1220;--panel:#151936;--accent:#7bd88f;--accent2:#8bd3ff;--text:#eef1ff;--muted:#a8b0d3;--danger:#ff6b6b;--warn:#ffd166}
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--text);
         background:radial-gradient(1000px 600px at 10% -10%, #1a1f45 0%, #0f1220 60%)}
    header{position:sticky;top:0;z-index:5;backdrop-filter:blur(8px);background:rgb(15 18 32 / 72%);
           border-bottom:1px solid #232955;padding:12px 16px;display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{margin:0;font-size:18px;letter-spacing:.3px}
    nav{display:flex;gap:8px;flex-wrap:wrap}
    nav button{background:var(--panel);color:var(--text);border:1px solid #232955;padding:8px 12px;border-radius:10px;cursor:pointer}
    nav button.active{border-color:var(--accent);box-shadow:0 0 0 2px rgb(123 216 143 / .25) inset}
    main{padding:16px;max-width:1200px;margin:0 auto}
    .card{background:linear-gradient(180deg,#161a3a 0%,#10142c 100%);border:1px solid #232955;border-radius:14px;padding:16px;margin:10px 0;box-shadow:0 8px 24px rgb(0 0 0 / .25)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:flex-end}
    .grid{display:grid;gap:12px}.grid.cols-2{grid-template-columns:repeat(auto-fit,minmax(260px,1fr))}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input,select{width:100%;background:#0c1030;color:var(--text);border:1px solid #232955;padding:10px 12px;border-radius:10px;outline:none}
    .btn{background:var(--accent);color:#0a1320;border:0;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:600}
    .btn.secondary{background:var(--accent2)}.btn.ghost{background:transparent;color:var(--text);border:1px solid #2a316a}.btn.danger{background:var(--danger);color:white}
    .muted{color:var(--muted)} .center{text-align:center}
    .pill{padding:6px 10px;border:1px solid #2a316a;border-radius:999px;color:var(--muted)}
    .timer{font-variant-numeric:tabular-nums}
    .question{font-size:28px;margin:8px 0 12px}
    table{width:100%;border-collapse:collapse;font-variant-numeric:tabular-nums}
    th,td{padding:8px 10px;border-bottom:1px solid #232955}
    tr:hover td{background:#101536}
    .ok{color:var(--accent)}.bad{color:var(--danger)}.warn{color:var(--warn)}
    .linklike{color:var(--accent2);cursor:pointer;text-decoration:underline}
  </style>
</head>
<body>
<header>
  <h1>🧩 Sequences – Solo</h1>
  <nav id="tabs"></nav>
  <div style="margin-left:auto"></div>
  <button class="btn ghost" id="exportJson">Export JSON</button>
  <button class="btn ghost" id="exportCsv">Export CSV</button>
  <button class="btn ghost" id="resetAll">Reset</button>
</header>
<main id="app"></main>

<script>
/************* Utils *************/
const $=(s,e=document)=>e.querySelector(s);
const $$=(s,e=document)=>[...e.querySelectorAll(s)];
const now=()=>performance.now();
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const fmtMs=ms=>(ms/1000).toFixed(2)+"s";
function dl(name,data,type){const a=document.createElement('a');a.href=URL.createObjectURL(new Blob([data],{type}));a.download=name;a.click();URL.revokeObjectURL(a.href);}
const rndInt=(a,b)=>Math.floor(Math.random()*(b-a+1))+a;
const pick=a=>a[Math.floor(Math.random()*a.length)];
const sign=()=>Math.random()<0.5?-1:1;

/************* Storage (scoped) *************/
const DBKEY='seq_db_v1', DEDUPKEY='seq_dedup_v1';
function load(key,def){try{return JSON.parse(localStorage.getItem(key))||structuredClone(def);}catch{ return structuredClone(def);}}
function save(key,val){localStorage.setItem(key,JSON.stringify(val));}
let DB=load(DBKEY,{sessions:[],highscores:{}});
let DEDUP=load(DEDUPKEY,{});
function pushSession(entry){
  DB.sessions.push({...entry, date:new Date().toISOString()});
  const sc=entry.stats?.score ?? entry.stats?.correct ?? 0;
  if(!DB.highscores.seq || sc>DB.highscores.seq.score){
    DB.highscores.seq={score:sc, when:new Date().toISOString(), detail:entry.stats};
  }
  save(DBKEY,DB);
}
function dedupInit(mod){ if(!DEDUP[mod]) DEDUP[mod]={list:[],set:{}}; }
function dedupHas(mod,s){ dedupInit(mod); return !!DEDUP[mod].set[s]; }
function dedupAdd(mod,s,cap=50000){ dedupInit(mod); if(!DEDUP[mod].set[s]){ DEDUP[mod].set[s]=1; DEDUP[mod].list.push(s); if(DEDUP[mod].list.length>cap){const old=DEDUP[mod].list.shift(); delete DEDUP[mod].set[old];} save(DEDUPKEY,DEDUP);} }
function dedupFindNew(mod,gen,sig,max=200){ for(let t=0;t<max;t++){ const it=gen(); const k=sig(it); if(!dedupHas(mod,k)){ dedupAdd(mod,k); return it; } } return gen(); }

/************* Presets *************/
const PRESETS={
  trade:{ label:'TradeSeq (Flow) 30/18', n:30, seconds:18*60, scoring:{correct:+1, wrong:0, skip:0}, target:22,
    weights:{AP:.30, GP:.12, FIBO:.10, GROWING_DIFF:.12, ALTERNATING:.10, INTERLEAVED:.10, QUADRATIC:.08, POW_OFFSET:.05, PRIME:.03},
    allow_neg:true, allow_frac:false },
  blue:{  label:'BlueSeq (Akuna) 24/16', n:24, seconds:16*60, scoring:{correct:+1, wrong:0, skip:0}, target:18,
    weights:{AP:.32, GP:.12, FIBO:.12, GROWING_DIFF:.12, ALTERNATING:.10, INTERLEAVED:.10, QUADRATIC:.07, POW_OFFSET:.03, PRIME:.02},
    allow_neg:true, allow_frac:false },
  brown:{ label:'BrownSeq (Maven) 26/15', n:26, seconds:15*60, scoring:{correct:+1, wrong:0, skip:0}, target:22,
    weights:{AP:.28, GP:.14, FIBO:.10, GROWING_DIFF:.12, ALTERNATING:.12, INTERLEAVED:.10, QUADRATIC:.08, POW_OFFSET:.04, PRIME:.02},
    allow_neg:true, allow_frac:false }
};
const TIERS={ easy:{start:[0,100],step:[-10,10],factor:[-3,3],maxAbs:500},
             mid :{start:[0,500],step:[-25,25],factor:[-4,4],maxAbs:5000},
             hard:{start:[-100,1000],step:[-50,50],factor:[-5,5],maxAbs:10000}};
const tierFor=(i,n)=> (i<Math.floor(n/3))?'easy':(i<Math.floor(2*n/3))?'mid':'hard';

/************* UI helpers *************/
function card(html=''){ const d=document.createElement('div'); d.className='card'; d.innerHTML=html; return d; }
function formRow(items){ const r=document.createElement('div'); r.className='row grid cols-2'; items.forEach(x=>r.appendChild(x)); return r; }
function btn(label,fn,cls='btn'){ const b=document.createElement('button'); b.className=cls; b.textContent=label; b.onclick=fn; return b; }
function numberField(label,min,max,step,val,onInput,allowFloat=false){
  const w=document.createElement('div'); const id='n'+Math.random().toString(36).slice(2);
  w.innerHTML=`<label for="${id}">${label}</label><input id="${id}" ${allowFloat?'':'inputmode="numeric"'} type="number" min="${min}" max="${max}" step="${step}" value="${val}">`;
  const el=$('input',w); el.addEventListener('input',e=>onInput(allowFloat?parseFloat(e.target.value):parseInt(e.target.value))); return w;
}
function selectField(label,opts,onCh,val){
  const w=document.createElement('div'); const id='s'+Math.random().toString(36).slice(2);
  w.innerHTML=`<label for="${id}">${label}</label><select id="${id}">${opts.map(([v,l])=>`<option value="${v}">${l}</option>`).join('')}</select>`;
  const el=$('select',w); el.value=val; el.addEventListener('change',e=>onCh(e.target.value)); return w;
}
function checkboxField(label,checked,onCh){ const w=document.createElement('div'); const id='c'+Math.random().toString(36).slice(2);
  w.innerHTML=`<label><input id="${id}" type="checkbox" ${checked?'checked':''}> ${label}</label>`;
  $('#'+id,w).addEventListener('change',e=>onCh(e.target.checked)); return w;
}
function table(rows, headers, rawCols = []) {
  const esc = s => (s ?? '').toString().replace(/[<>&]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[c]));
  const thead = `<thead><tr>${headers.map(h => `<th>${esc(h)}</th>`).join('')}</tr></thead>`;
  const tbody = `<tbody>${
    rows.map(r => `<tr>${
      r.map((c, idx) => `<td>${rawCols.includes(idx) ? (c ?? '') : esc(c)}</td>`).join('')
    }</tr>`).join('')
  }</tbody>`;
  return `<table>${thead}${tbody}</table>`;
}

/************* App-Shell *************/
const tabs=[
  {id:'seq', label:'Sequences', view:viewSeq},
  {id:'stats', label:'Statistik', view:viewStats},
  {id:'settings', label:'Einstellungen', view:viewSettings},
];
let currentTab=localStorage.getItem('seq_tab')||'seq';
function renderTabs(){ const nav=$('#tabs'); nav.innerHTML=''; tabs.forEach(t=>{ const b=document.createElement('button'); b.textContent=t.label; b.className=currentTab===t.id?'active':''; b.onclick=()=>{currentTab=t.id; localStorage.setItem('seq_tab',currentTab); render();}; nav.appendChild(b);});}
function render(){ renderTabs(); const root=$('#app'); root.innerHTML=''; (tabs.find(t=>t.id===currentTab)||tabs[0]).view(root); }

/************* Export / Reset *************/
$('#exportJson').onclick=()=>dl('seq_stats_'+new Date().toISOString().slice(0,10)+'.json',JSON.stringify(DB,null,2),'application/json');
$('#exportCsv').onclick=()=>{
  const rows=[["module","date","score","correct","total","avgMs","detail_json","settings_json"]];
  for(const s of DB.sessions.filter(s=>s.module==='seq')){
    rows.push(['seq',s.date,s.stats?.score??'',s.stats?.correct??'',s.stats?.total??'',s.stats?.avgMs??'',JSON.stringify(s.perQuestion||[]),JSON.stringify(s.settings||{})]);
  }
  dl('seq_stats_'+new Date().toISOString().slice(0,10)+'.csv', rows.map(r=>r.map(x=>`"${String(x).replace(/"/g,'""')}"`).join(',')).join('\n'), 'text/csv');
};
$('#resetAll').onclick=()=>{ if(confirm('Alle lokalen Daten (Sessions/Highscores/Dedup) löschen?')){ localStorage.removeItem(DBKEY); localStorage.removeItem(DEDUPKEY); DB=load(DBKEY,{sessions:[],highscores:{}}); DEDUP={}; render(); } };

/************* Generatoren *************/
function withinAbs(arr,maxAbs){ return arr.every(x=>Number.isFinite(x) && Math.abs(x)<=maxAbs); }
function genAP(tier){
  const R=TIERS[tier]; const a0=rndInt(R.start[0],R.start[1]); let d=0; while(d===0) d=rndInt(R.step[0],R.step[1]);
  const seq=[a0]; for(let i=1;i<6;i++) seq.push(seq[i-1]+d);
  return {type:'AP',params:{a0,d}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genGP(tier){
  const R=TIERS[tier];
  let r=0; while([ -1,0,1 ].includes(r)) r=pick([ -5,-4,-3,-2, 2,3,4,5 ]);
  let a0=rndInt(1,Math.max(3,Math.min(10,Math.floor(R.start[1]/Math.abs(r)**5))));
  if(sign()<0) a0*=-1;
  const seq=[a0]; for(let i=1;i<6;i++) seq.push(seq[i-1]*r);
  return {type:'GP',params:{a0,r}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genFibo(tier){
  const R=TIERS[tier];
  let a0=rndInt(1,9)*sign(), a1=rndInt(1,9)*sign(), k=rndInt(-2,2);
  const seq=[a0,a1]; for(let i=2;i<6;i++) seq.push(seq[i-1]+seq[i-2]+k);
  return {type:'FIBO',params:{a0,a1,k}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genGrowingDiff(tier){
  const R=TIERS[tier];
  const t0=rndInt(R.start[0],R.start[1])*sign();
  let d0=rndInt(-8,8); if(d0===0) d0=2;
  let delta=rndInt(-4,4); if(delta===0) delta=1;
  const seq=[t0]; let d=d0;
  for(let i=1;i<6;i++){ seq.push(seq[i-1]+d); d+=delta; }
  return {type:'GROWING_DIFF',params:{t0,d0,delta}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genAlternating(tier){
  const R=TIERS[tier];
  const t0=rndInt(R.start[0],R.start[1])*sign();
  let p=rndInt(2,12), q=rndInt(2,12);
  if(p===0) p=2; if(q===0) q=3;
  const seq=[t0];
  for(let i=1;i<6;i++){
    const add = (i%2===1) ? p : -q;
    seq.push(seq[i-1]+add);
  }
  return {type:'ALTERNATING',params:{t0,p,q}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genInterleaved(tier){
  const R=TIERS[tier];
  const a1=rndInt(R.start[0],R.start[1])*sign(), d1=rndInt(-10,10)||2;
  const a2=rndInt(R.start[0],R.start[1])*sign(), d2=rndInt(-10,10)||3;
  const seq=[];
  for(let i=0;i<6;i++){
    if(i%2===0){ const k=Math.floor(i/2); seq.push(a1 + k*d1); }
    else       { const k=Math.floor(i/2); seq.push(a2 + k*d2); }
  }
  return {type:'INTERLEAVED',params:{a1,d1,a2,d2}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genQuadratic(tier){
  const R=TIERS[tier];
  let a=rndInt(-2,2); if(a===0) a=1;
  let b=rndInt(-5,5), c=rndInt(-20,20);
  const seq=[]; for(let i=1;i<=6;i++) seq.push(a*i*i + b*i + c);
  return {type:'QUADRATIC',params:{a,b,c}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function genPowOffset(tier){
  const R=TIERS[tier];
  const useCube=Math.random()<0.35;
  const k=rndInt(-10,10);
  const startIdx=rndInt(1,3);
  const seq=[]; for(let i=startIdx;i<startIdx+6;i++){ seq.push((useCube? i*i*i : i*i) + k); }
  return {type:'POW_OFFSET',params:{cube:useCube,k,startIdx}, seq, next:seq[5], ok:withinAbs(seq,R.maxAbs)};
}
function primesUpTo(n){ const res=[]; let x=2; function isP(v){ if(v<2) return false; for(let d=2; d*d<=v; d++) if(v%d===0) return false; return true; }
  while(res.length<n){ if(isP(x)) res.push(x); x++; } return res; }
function genPrime(tier){
  const base = tier==='easy'? 1 : (tier==='mid'? 4 : 8);
  const p=primesUpTo(40); const start=rndInt(base,base+4);
  const seq=[]; for(let i=0;i<6;i++) seq.push(p[start+i]);
  return {type:'PRIME',params:{start}, seq, next:seq[5], ok:true};
}
const GENERATORS={AP:genAP, GP:genGP, FIBO:genFibo, GROWING_DIFF:genGrowingDiff, ALTERNATING:genAlternating,
  INTERLEAVED:genInterleaved, QUADRATIC:genQuadratic, POW_OFFSET:genPowOffset, PRIME:genPrime};
function weightedPick(weights){
  const entries=Object.entries(weights); const sum=entries.reduce((a,[,w])=>a+w,0); let r=Math.random()*sum;
  for(const [k,w] of entries){ if((r-=w)<=0) return k; } return entries[0][0];
}

/************* View: Sequences *************/
function viewSeq(root){
  root.appendChild(card(`<h2>🔗 Sequences</h2>
    <div class="muted">Realistische Presets (Flow/Akuna/Maven). 5 Terme → nächster Term. Integer-only (keine Brüche). <b>Auto-Advance</b>, <b>Pause/Resume</b> (Pausezeit zählt nicht), <b>Skip</b> ohne Malus, <b>Abbrechen</b> speichert nicht. Keine Wiederholungen durch Dedup.</div>`));
  const cfg={preset:'trade', ...PRESETS.trade, auto:true};
  const panel=card(); panel.appendChild(formRow([
    selectField('Preset', Object.entries(PRESETS).map(([k,p])=>[k,p.label]), v=>Object.assign(cfg,{preset:v, ...PRESETS[v]}), cfg.preset),
    numberField('Anzahl',5,80,1,cfg.n,v=>cfg.n=v),
    numberField('Zeit (s)',60,3600,10,cfg.seconds,v=>cfg.seconds=v),
    numberField('Ziel (Ready=100%)',1,100,1,cfg.target,v=>cfg.target=v),
    checkboxField('Auto-Advance', cfg.auto, v=>cfg.auto=v),
    btn('Start',()=>run())
  ]));
  root.appendChild(panel);

  const best=DB.highscores.seq; const hi=card('<h3>🏆 Highscore</h3>');
  hi.insertAdjacentHTML('beforeend', best?`<div class="pill">Score: <b>${best.score}</b> · ${new Date(best.when).toLocaleString()}</div>`:'<div class="muted">Noch kein Highscore.</div>');
  root.appendChild(hi);

  function sigOf(item){ return `${item.type}|${JSON.stringify(item.params)}`; }

  // Vorab-Generator (stabilreihenfolge)
  function generateOne(i){
    const tier=tierFor(i,cfg.n);
    let item=null, tries=0;
    while(!item || !item.ok){
      const pat=weightedPick(cfg.weights || PRESETS.trade.weights);
      item = GENERATORS[pat](tier);
      if(++tries>50) break;
    }
    if(!item || !item.ok) item=genAP(tier);
    return dedupFindNew('seq', ()=>item, sigOf, 200);
  }

  function run(){
    // Items vorab erzeugen (damit Backlog stabil ist)
    const items=[...Array(cfg.n)].map((_,i)=>generateOne(i));
    const answered = Array(cfg.n).fill(null); // {user, ans, ms, correct, q, type}
    const backlog=[];                         // Indizes offener (geskippt) Fragen

    const ui=card(); root.appendChild(ui);
    ui.innerHTML=`
      <div class="row" style="justify-content:space-between;align-items:center">
        <span class="pill">Preset: ${PRESETS[cfg.preset]?.label || 'custom'}</span>
        <span class="pill">Zeit: <span id="t" class="timer"></span></span>
        <span class="pill">Frage: <b id="qc">1</b> / ${cfg.n}</span>
        <span class="pill linklike" id="openPill" title="Zur nächsten offenen Aufgabe springen">Offen: <b id="openCnt">0</b></span>
      </div>
      <div class="question" id="q"></div>
      <div class="row">
        <div style="flex:1">
          <label>Nächstes Element</label>
          <div class="row" style="gap:6px">
            <input id="a" inputmode="decimal" placeholder="Zahl" style="flex:1">
            <button id="minus" class="btn ghost" title="Minus">-</button>
          </div>
        </div>
        <button class="btn" id="ok">OK</button>
        <button class="btn ghost" id="skip">Skip</button>
        <button class="btn ghost" id="pause">Pause</button>
        <button class="btn danger" id="abort">Abbrechen</button>
      </div>
      <div class="muted" id="info"></div>`;

    const el={t:$('#t',ui),qc:$('#qc',ui),q:$('#q',ui),a:$('#a',ui),ok:$('#ok',ui),skip:$('#skip',ui),
              pause:$('#pause',ui),abort:$('#abort',ui),info:$('#info',ui),minus:$('#minus',ui),
              openCnt:$('#openCnt',ui),openPill:$('#openPill',ui)};

    const totalMs=cfg.seconds*1000;
    let i=0, curIdx=0, correct=0;
    let paused=false, pauseT=0, tStart=performance.now(), tPause=0, running=true;
    let qStart=now(), qPaused=0, qPauseStart=0;

    function updateOpenPill(){ el.openCnt.textContent=String(backlog.length); }
    function answeredCount(){ return answered.filter(x=>x!==null).length; }

    function tick(){
      let tNow=performance.now(); if(paused) tNow=tPause;
      const used=tNow-tStart-pauseT; const left=Math.max(0,totalMs-used);
      el.t.textContent=(left/1000).toFixed(1)+'s';
      if(left<=0&&running){ finish(); return; }
      if(running) requestAnimationFrame(tick);
    }

    function chooseNext(){
      // Reihenfolge: zuerst normale Reihe bis N, danach offene
      if(i < cfg.n){ curIdx = i; i++; return true; }
      if(backlog.length>0){ curIdx = backlog[0]; return true; }
      return false;
    }

    function show(){
      const itm = items[curIdx];
      el.q.textContent = itm.seq.slice(0,5).join(' , ')+' , ?';
      el.a.value=''; el.a.focus();
      el.qc.textContent = String(Math.min(cfg.n, answeredCount()+1));
      el.info.textContent = 'Bewertung: +1 richtig, 0 sonst (Skip ohne Malus). Klicke „Offen“, um zu offenen Aufgaben zu springen.';
      qStart=now(); qPaused=0;
    }

    function startNext(){
      if(chooseNext()){ show(); }
      else { finish(); }
    }

    function submit(kind){
      const raw=el.a.value.trim();
      const user=(kind==='skip'||raw==='')?null:Number(raw.replace(',','.'));
      const itm = items[curIdx];

      if(user===null){
        // Markiere als offen (nur falls noch nicht beantwortet & nicht schon im Backlog)
        if(answered[curIdx]===null && !backlog.includes(curIdx)) backlog.push(curIdx);
        updateOpenPill();
        // Wenn diese Frage aus dem Backlog kommt: rotiere ans Ende
        if(backlog[0]===curIdx){ backlog.push(backlog.shift()); }
        startNext();
        return;
      }

      const ms=Math.round(now()-qStart - qPaused);
      const ok=(Math.abs(user-itm.next)<1e-9);
      answered[curIdx]={q:itm.seq.slice(0,5).join(' , '), user, ans:itm.next, correct:ok, ms, type:itm.type};
      if(ok) correct++;

      // Falls diese Frage im Backlog war → entfernen
      const k=backlog.indexOf(curIdx); if(k>=0) backlog.splice(k,1);
      updateOpenPill();

      startNext();
    }

    function pause(){
      if(!paused){ paused=true; tPause=performance.now(); qPauseStart=now(); el.pause.textContent='Resume'; }
      else { paused=false; pauseT+=performance.now()-tPause; qPaused+=now()-qPauseStart; el.pause.textContent='Pause'; requestAnimationFrame(tick); }
    }

    function abort(){ if(confirm('Ohne Speichern beenden?')){ running=false; ui.innerHTML='<div class="card">Abgebrochen – nicht gespeichert.</div>'; } }

    function finish(){
      running=false;
      // Restliche offene (nie beantwortete) bleiben ohne Eintrag → als Skip ausgeben
      const per=[];
      for(let j=0;j<cfg.n;j++){
        if(answered[j]) per.push(answered[j]);
        else per.push({q:items[j].seq.slice(0,5).join(' , '), user:null, ans:items[j].next, correct:null, ms:'', type:items[j].type});
      }
      const answeredWithMs = per.filter(x=>typeof x.ms==='number');
      const avg = answeredWithMs.length? Math.round(answeredWithMs.reduce((a,x)=>a+x.ms,0)/answeredWithMs.length):0;
      const stats={correct,total:cfg.n,avgMs:avg,score:correct};
      const readiness = clamp(Math.round((correct/(cfg.target||cfg.n))*100),0,200);

      pushSession({module:'seq', preset:cfg.preset, stats, perQuestion:per, settings:{...cfg}});
      const rows=[["#","sequence","your","correct","ms","type","status"]];
      per.forEach((x,j)=>rows.push([
        j+1,x.q,x.user==null?'':x.user,x.ans,x.ms,x.type,
        x.correct===true?'OK':(x.user===null?'SKIP':'X')
      ]));
      const csv=rows.map(r=>r.map(v=>`"${String(v).replace(/"/g,'""')}"`).join(',')).join('\n');
      const txt=per.map((x,j)=>`${j+1}. [${x.q}] -> your=${x.user==null?'':x.user} | correct=${x.ans} | ${x.correct===true?'OK':(x.user===null?'SKIP':'X')} | ${x.ms||''}ms | ${x.type}`).join('\n');

      ui.innerHTML=`<h3>Ergebnis</h3>
        <div class="row">
          <span class="pill">Richtig: <b class="ok">${stats.correct}</b> / ${stats.total}</span>
          <span class="pill">Ø Zeit (nur beantwortet): <b>${fmtMs(stats.avgMs)}</b></span>
          <span class="pill">Ready: <b>${readiness}%</b> (Ziel ${cfg.target})</span>
        </div>
        <div class="row"><button class="btn" id="dlCsv">Download CSV</button><button class="btn ghost" id="dlTxt">Download TXT</button></div>
        ${table(per.map((x,idx)=>[
          idx+1,x.q,x.user==null?'—':x.user,x.ans,(x.ms? (x.ms/1000).toFixed(2)+'s':''),
          x.type, x.correct===true?'✅':(x.user===null?'⏭':'❌')
        ]),['#','Sequenz','Deine','Korrekt','Zeit','Typ','OK'])}`;

      $('#dlCsv',ui).onclick=()=>dl('seq_'+new Date().toISOString().replace(/[:.]/g,'-')+'.csv',csv,'text/csv');
      $('#dlTxt',ui).onclick=()=>dl('seq_'+new Date().toISOString().replace(/[:.]/g,'-')+'.txt',txt,'text/plain');
      render();
    }

    // Events
    el.ok.onclick=()=>submit('ok');
    el.skip.onclick=()=>submit('skip');
    el.pause.onclick=pause;
    el.abort.onclick=abort;
    el.minus.onclick=()=>{ if(!el.a.value.startsWith('-')) el.a.value='-'+el.a.value; el.a.focus(); const pos=el.a.value.length; el.a.setSelectionRange(pos,pos); };
    el.a.addEventListener('keydown',e=>{ if(e.key==='Enter') submit('ok'); });
    el.a.addEventListener('input',()=>{ if(!cfg.auto) return; const raw=el.a.value.trim(); if(!raw) return; const v=Number(raw.replace(',','.')); const need=items[curIdx].next; if(Math.abs(v-need)<1e-9) submit('ok'); });
    el.openPill.onclick=()=>{ // springe direkt zur nächsten offenen
      if(backlog.length===0) return;
      curIdx = backlog[0];
      show();
    };

    updateOpenPill();
    requestAnimationFrame(tick);
    startNext();
  }
}

/************* Statistik *************/
function viewStats(root){
  root.appendChild(card(`<h2>📊 Statistik</h2><div class="muted">Alle Läufe, Ø-Zeit/Frage, Accuracy & Highscore.</div>`));
  const arr=DB.sessions.filter(s=>s.module==='seq');
  const sum=f=>arr.reduce((a,x)=>a+(f(x)||0),0);
  const avgMs=Math.round(sum(x=>x.stats?.avgMs)/Math.max(1,arr.length));
  const acc = sum(x=>x.stats?.correct)/Math.max(1,sum(x=>x.stats?.total))*100;
  const el=card(`<div class="row">
      <span class="pill">Sessions: <b>${arr.length}</b></span>
      <span class="pill">Ø Zeit/Frage: <b>${isFinite(avgMs)?fmtMs(avgMs):'—'}</b></span>
      <span class="pill">Ø Accuracy: <b>${isFinite(acc)?acc.toFixed(1):'—'}%</b></span>
      <span class="pill">Highscore: <b>${DB.highscores.seq?.score ?? '—'}</b></span>
    </div>`);
  const rows=arr.slice(-50).map((s,i)=>[
    i+1, new Date(s.date).toLocaleString(),
    `${s.stats.correct}/${s.stats.total}`,
    (s.stats.avgMs/1000).toFixed(2)+'s',
    s.stats.score ?? '—',
    `<span class="linklike" data-idx="${DB.sessions.indexOf(s)}">Details</span>`
  ]);
  el.insertAdjacentHTML('beforeend', table(rows,['#','Datum','Richtig','Ø Zeit','Score','Session'], [5]));
  root.appendChild(el);
  el.addEventListener('click',ev=>{
    const t=ev.target.closest('.linklike'); if(!t) return;
    const idx=+t.dataset.idx; const s=DB.sessions[idx];
    const txt=(s?.perQuestion||[]).map((x,j)=>`${j+1}. [${x.q}] -> your=${x.user==null?'':x.user} | correct=${x.ans} | ${(x.correct===true?'OK':(x.user===null?'SKIP':'X'))} | ${x.ms||''}ms | ${x.type}`).join('\n');
    const url=URL.createObjectURL(new Blob([txt],{type:'text/plain'}));
    const a=document.createElement('a'); a.href=url; a.download='session_'+new Date(s.date).toISOString().replace(/[:.]/g,'-')+'.txt'; a.click(); URL.revokeObjectURL(url);
  });
}

/************* Einstellungen *************/
function viewSettings(root){
  root.appendChild(card(`<h2>⚙️ Einstellungen</h2><div class="muted">Dedup & Datenpflege.</div>`));
  const box=card(); box.appendChild(formRow([
    btn("Dedup-Pool 'seq' leeren",()=>{ delete DEDUP['seq']; save(DEDUPKEY,DEDUP); alert("Pool geleert."); }),
    btn("Nur Highscore löschen",()=>{ delete DB.highscores.seq; save(DBKEY,DB); alert("Highscore gelöscht."); },'btn ghost'),
    btn("Alle Seq-Sessions löschen",()=>{ DB.sessions=DB.sessions.filter(s=>s.module!=='seq'); save(DBKEY,DB); alert("Sequences-Sessions gelöscht."); render(); },'btn danger'),
  ]));
  root.appendChild(box);
}

/* Start */
render();
</script>
</main>
</body>
</html>
